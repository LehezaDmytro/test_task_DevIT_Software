//3. Напишите функцию обертку, которая на вход принимает массив функций и их параметров, а возвращает массив результатов их выполнения. Количество аргументов исполняемой функции не ограничено!

// Створюємо асинхронну функцію bulkRun, яка приймає масив функцій та їх аргументів
async function bulkRun(functionsAndArgs) {
  // Перевіряємо, чи є вхідні дані масивом
  if (!Array.isArray(functionsAndArgs)) {
    throw new TypeError("Параметр functionsAndArgs має бути масивом.");
  }

  //Створюємо змінну в яку будуть записані результати виконання функцій
  const results = [];

  // Ітеруємось по масиву функцій та їх аргументів за допомогою for...of
  for (const [func, args] of functionsAndArgs) {
    // Перевіряємо, чи є func функцією та args масивом
    if (typeof func !== "function" || !Array.isArray(args)) {
      throw new Error(
        "Елементи масиву functionsAndArgs мають бути в форматі [функція, масив аргументів]."
      );
    }

    const result = await new Promise((resolve) => {
      // Створюємо функцію зворотного виклику (callback), яка буде викликана функцією
      // після завершення її виконання та передасть результат функції в resolve
      const callback = (data) => resolve(data);

      // Викликаємо функцію func з переданими аргументами та функцією callback
      func(...args, callback);
    });

    // Додаємо результат виконання функції до масиву results
    results.push(result);
  }

  // Повертаємо масив результатів після виконання всіх функцій
  return results;
}

// Визначення трьох прикладів функцій, які будуть виконані
const f1 = (cb) => {
  cb(1);
};

const f2 = (a, cb) => {
  cb(a);
};

const f3 = (a, b, cb) => {
  setTimeout(() => {
    cb([a, b]);
  }, 1000);
};

// Викликаємо функцію bulkRun з масивом функцій та їх аргументів
bulkRun([
  [f1, []],
  [f2, [11]],
  [f3, [8, 6]],
]).then(console.log); // Виводимо результат виконання в консоль
